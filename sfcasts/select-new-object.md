# SELECTing into a New DTO Object

Coming soon...

Having the flexibility to select whatever data we want is awesome. Though dealing with associative arrays that we get back is less than awesome. I typically try to deal with objects whenever possible. Fortunately, Doctrine gives us a simple way to improve this situation. Where we can take this data and just throw it into an object for us. So step one, we're going to create a new class that's going to hold this data. So I'm going to create a new directory called `src/Model`. This could be called anything. Then I'm going to call this class, how about `CategoryFortuneStats`. We're creating this class entirely just to hold that data. So I'm going to give it the public function `_construct()`. And then it's going to give it a couple of public columns just for simplicity. So `public int $fortunesPrinted`, `public float $fortunesAverage`, and a `public string $categoryName`. Love it. Now, obviously, one of the things that we could do is just get back this result here, and we could just create one of those new `CategoryFortuneStats` objects and just pass in that data that we selected above. That's a great option, dead simple, and it would allow us to return an object from this method instead of an array. But Doctrine actually makes it even simpler than that. It's kind of a little known feature. So inside of, I'm actually going to add a new `select` up here that's going to contain all of these selects together. And actually, I'm also going to put a `sprintf` up there. You'll see why in a second. And then inside here, check this out. We're going to say `new %s( )`, and then we're actually going to basically just pass in the arguments to that method. Now for the `%s`, just so you don't get confused here, here's where I pass in that `%s` right there. There we go. For the `%s`, I'm going to pass in `CategoryFortuneStats::class`. So we're basically doing the same `new App\Model\CategoryFortuneStats`. I just didn't want to type that ugly class name inside of here, so I did the `%s` instead. But yeah, inside of the new here, we're just going to grab the three columns that are associated with that. So we'll select that data, this data, and this data down here. Wild, huh? And down here, I'm going to `dd($result)` so we can see what that looks like. All right, so I'll go over and refresh and oh, I get an error, T close parentheses got as. So as soon as you're creating into an object, it doesn't make sense for us to alias those things anymore. It's going to pass whatever this is to the first argument of our constructor. It's going to pass this to the second argument and this to the third argument. So the aliases don't make sense anymore. And in fact, we are not allowed to have the aliases anymore. So now, got it. Yes, check that out. We have our object with our data in it. That is sweet. So we can go over and clean up our method. We don't return an array anymore. We return a `CategoryFortuneStats` and I'll remove the `dd($result)` down there. Then over in our controller to kind of show off how much nicer this is, I'll change this result to, how about stats? And then it's going to be `stats->fortunesPrinted`, `stats->fortunesAverage`, and `stats->name`, or we could have called that `stats->categoryName`. So much nicer and our template should still work. Got it. All right, next up. Sometimes queries are so complex. You need to write just raw native SQL queries. Let's talk about how to do that.
