# Using GROUP BY to Fetch & Count in 1 Query

Coming soon...

Alright, one last challenge for us. On this homepage, we have seven queries. It's one query for the six categories, and then another query for the fortune cookies to count how many fortune cookies are here, and how many are here, and how many are here, which totals seven. You can see that on here. Now, that's not really necessarily a problem. You should optimize performance until you actually see there's a problem. But let's see if we can challenge ourselves to make this query go down to just one query. So if you think about it, what we can do is we could query for all categories, join over to the related fortune cookies, group by the category, and then count the fortune cookies. That didn't make total sense. It's gonna be easier when we see it. So this, for the controller, we're on the homepage. We're using the find all ordered instead of category repository. So let me find find all ordered. Here we go. And check this out. So we're already selecting from a category. I'm now gonna select something else and say add select, count, and we're gonna count fortune cookie.id as fortune cookies total. Now, fortune cookie here, we don't have that alias yet. I haven't joined over that. So let's join. Let's do our left join on category.fortuneCookies, and we'll alias that to fortuneCookie. And then the last thing we need to do for this count to work correctly, we need to do a add group by category.id. All right, let's see what that gives us back. So down here, I'm actually gonna DD query arrow get results. And as a reminder, what this is returning right now is an array of category objects. So I'm gonna refresh. It is an array, but it's now an array of arrays where the zero key is a category object, and then we have this extra fortune cookies total. So it's selected exactly what we want, but it changed the underlying structure, which it sort of had to, right? It needed to somehow give us the category object and the extra column behind the scenes. But it is what we want. So check this out. Over here, let's get rid of our DD. This is returning an array. I'm actually gonna remove this at return up here because that's wrong now.  I could make it smarter, but I'll leave that for later. And let's head into our homepage because the structure just changed, right? So if we look here, we're looking over category in categories. This is now going to be one of those arrays with a zero key on it. So I'm actually gonna say for category data in categories, and then right inside here, I can say set category equals category data zero. Now I wanna talk about that in a second, but before we do, we can also go down here to the count. This is where we're going across the relationship. Now we're gonna say category data dot fortune cookies total. And now, check it out. The page works, one query. So the worst part about this is that the structure changed and that we're reading the zero key off of this. So I'm not gonna do it, but a better solution might be to leverage a DTO object to hold this. So for example, we might create a new class called category with fortune count with two properties, a category object and the fortune count. Then in this method, that's what we would return. We would actually loop over query error, get results and create one of those category with fortune count objects for each one of these. And ultimately we'd return an array of those DTO objects from this. The point is we'd be returning an array of objects again, instead of like an array of arrays, like we saw a second ago. Now, speaking of that changed structure, if we search for something, we get an error, impossible to access a key zero on an object. So it's this line right here. That's because when we search for something, we use the search method and surprise, the search method does not have this order by, so it's still returning an array of category objects. So let's create a private function down here that can hold that group by, and then we'll call it from both functions. So private function, add group by category, query builder, QB and we'll return a query builder. And actually I'll be lazy, like normal. Let us be lazy to say QB equals null. And then what we'll do here is return parentheses, QB colon colon, this arrow create query builder, category.  And then I'm gonna go up here and kind of steal the logic we just did, the add, select, left join and group by, and put that down here. You know what, this add group by category is not even a good name. Add group by category and count fortunes. How about that? Awesome. Then back up here, of course this is gonna be much simpler. We can just change this to add group by category and count fortunes. And then we don't need the group by, all we need is the order by. And let's try that over here. Oh, of course it's not gonna work on the search yet. On the homepage, that still works. Let's go forward, this is still broken. But we can use that down in search. Let's do that. So QB equals this arrow, add group by category and count fortunes. And pass a QB. And now, oh, error. Error, fortune key is already defined. So inside of here, we are joining. And down here, we are joining, which we don't really need to do anymore. So I'm actually just going to grab this, pop it right there. And we're good. One query on the search page also. All right, friends, we're done. Thanks for joining me on this. Doctrine Query stuff is just weird and cool and fun. And I hope you enjoy this as much as I did. If you have some crazy situation we haven't thought about, you wanna talk it over, we're always here for you down in the comments. All right, friends, we'll see you next time.
