# Using GROUP BY to Fetch & Count in 1 Query

*One last challenge* for us. On the homepage, we have seven queries. That's one query for each of the six categories, and another query for the fortune cookies count. You can see those queries here. That's not really necessarily a problem, and you shouldn't worry about optimizing performance until you actually see that there's a problem. But let's see if we can *challenge* ourselves to turn our seven queries into *one*. If you think about it, we *could* query for all categories, `JOIN` over to the related fortune cookies, `GROUP BY` the category, and then `COUNT` the fortune cookies. That will make more sense when you see it.

Head over to `FortuneController.php`. We're on the homepage, and we're using the `findAllOrdered()` method from `$categoryRepository`. So we'll go look for `findAllOrdered()` and... here we go. You can see here that we're already selecting from `category`. Now we're going to select something else. Say `->addSelect('COUNT(fortuneCookie.id) AS fortuneCookiesTotal')`. We don't have this `fortuneCookie` alias yet, and I haven't joined over to that, so let's do it. Add `->leftJoin('category.fortuneCookies')`, and we'll alias that to `fortuneCookie`. The last thing we need to do for this `COUNT` to work correctly is add `->addGroupBy('category.id')`.

Okay, let's see what we get! Down here, I'll `dd($query->getResult())` so we can see the results. As a reminder, this currently returns an `array` of `Category` objects. If we refresh... it *is* an array, but it's now an *array of arrays* where the `0` key is a `Category` object, and then we have this extra `fortuneCookiesTotal`. So... it selected exactly what we wanted, but it changed the underlying structure. And it kind of *had* to, right? It needed to somehow give us the `Category` object *and* the extra column behind the scenes. This *is* what we want, but we can take this a step firther.

Over here, let's get rid of our `dd` statement. This is returning an `array`, so we need to remove this `@return` up here because that's wrong now. We *could* make this smarter, but we'll leave that for later. Since the structure just changed, head over to `homepage.html.twig`. Here, you can see that we're looping over `category in categories`. This is going to be one of those arrays with a `0` key on it, so let's change this to say `for categoryData in categories` and, inside here, say `set category = categoryData[0]`. We'll talk more about that in a second, but before we do, we'll scroll over here to the `COUNT`. This is where we're going across the relationship. We're going to change this to `categoryData.fortuneCookiesTotal`. If we test this now... the page works, and we have *one* query!

Really, the worst part about this is that the structure changed and we're now reading the `0` key here. We won't do this, but a *better* solution might be to leverage a DTO object to hold this. For example, we might create a new class called `CategoryWithFortuneCount` with two properties - a `Category` object and the `fortuneCount`. In this method, that's what we would return. We would actually loop over `$query->getResults()` and create a `CategoryWithFortuneCount` object for each one of these. And *ultimately*, we'd return an array of DTO objects from that. The point is, we would be returning an array of objects again instead of an *array of arrays*, like we saw a moment ago.

Speaking of that changed structure, if we search for something... we get an error:

`Impossible to access a key "0" on an object of class "App\Entity\Category" that does not implement ArrayAccess interface.`

It's this line right here. That's because, when we search for something, we use the `search()` method and... surprise! The `search()` method doesn't have `->addOrderBy()`, so it's still returning an array of `Category` objects. To fix that, let's create a `private function` down here that can hold `addGroupBy`, and then we'll call it from both functions. Say `private function addGroupByCategory(QueryBuilder $qb)` and we'll return a `QueryBuilder`. We'll also be lazy and change this to `QueryBuilder $qb = null`. Then, we'll `return ($qb ?? $this->createQueryBuilder('category'))`.

Now, we can head up here and steal some of this logic - the `->addSelect()`, `->leftJoin()`, and `->addGroupBy()` - and paste that down here. To keep it simple, I'll change this `addGroupByCategory()` to `addGroupByCategoryAndCountFortunes()`. *Awesome*. Back up here, we can simplify this as well. Change *this* to `addGroupByCategoryAndCountFortunes()`... and then we don't need the `->addGroupBy()`, `->leftJoin()`, or `->addSelect()` anymore.

Let's try this now! Over on the homepage... that *still* works. If we go forward... this is still broken. But we can use that! Down in `search()` say `$qb = $this->addGroupByCategoryAndCountFortunes($qb)`. And now... *another* error:

`'fortuneCookie' is already defined.`

That makes sense. We are joining up here *and* down here, and we don't need to do that in both places. Grab this... and pop it right here. If we check this one more time... it works! *And* we only have one query!

All right, friends! We're *done*! Thanks for joining me for this magical ride through all things Doctrine Query. This stuff is just weird, cool and fun. I hope you enjoyed it as much as I did. If you encounter some *crazy* situation we haven't thought about yet, have any questions, *or* pictures of your cat, we're always here for you down in the comments. Okay, friends! See you next time!
