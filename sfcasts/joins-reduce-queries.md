# JOINs and addSelect Reduce Queries

Coming soon...

Until then, here is the legacy version: https://symfonycasts.com/screencast/doctrine-queries-legacy/joins-reduce-queries

When we're on the homepage, we see seven queries down here. It's one to get all of the categories, and then a second one to get all of the fortunes for this category, the fortunes for this category, and so on until we get seven. You can see that inside of here. This is our main query up here that's selecting from category. Then each of these down here is selecting fortune data for a specific category. Category three, category four, category two, category six. So why? Well, if you use Doctrine, you recognize what's happening here. Doctrine loads its relationships lazily. So if we follow the logic here in our `FortuneController`, what we first do is we query for an array of `Category` objects. In that query, if you look at it, it's just selecting category data. It's not selecting fortune cookie data. We do, it's just category data. But then if we go into our template, `templates/fortune/homepage.html.twig`, when we loop over those categories, at one point we call `category.fortunescookie | length`. So in PHP land, what's happening here is we are calling the `getFortuneCookies()` method on `Category`. Now this exact moment, Doctrine has not yet queried for the fortune cookie data for this category. So right as soon as we call that method, that's when it queries out to Doctrine and says, give me all of the fortune cookie data for this category, which it then sets onto this property magically and returns to us. So it's actually at this moment inside of Twig when that second, third, fourth, fifth, sixth, and seventh query is actually fired off. This is called the N plus one problem, where you have N number of queries for items on your page, plus one for the main query. So six plus one equals seven. And it's not necessarily a problem. You don't necessarily need to run and fix this, but it can be fixed by a joint. After all, when we query for these categories, we're already joining over to the fortune cookie table. So if we just grabbed the data in the first query, couldn't we build this whole page with one query? The answer is yes. To see this fix in action, I'm first actually going to search for something.

There we go, because this will trigger our `search` method that already has our join on it. And you can see over here, since we have five results, we have six queries. All right, so we're already joining over to `fortuneCookies`. We're just not selecting its data. So the solution is really simple. Again, the order doesn't matter here. We say `addSelect`, and then we say `fortuneCookie`. That's it. Watch, I have somebody go over, refresh. The queries went down to one and the page still works. If you open that up, and let's actually view the format of query. Yes, you can see it's joining over to `fortuneCookie`, but it's also grabbing the `fortuneCookie` data all at the same time. N plus one problem solved. 

But this is kind of crazy. So I want to point out a few things. First, because we're inside of `CategoryRepository`, when we call `createQueryBuilder('category')`, implicitly, that's basically saying that includes a `select category`. So we're actually selecting all the category data now and all of the fortune cookie data now. But our page still works, which means that even though we're now selecting from two tables, our method is still apparently returning an array of `Category` objects, not a mixture of `Category` and `FortuneCookie` data. And that is, in fact, exactly how it works. Because we're selecting from the main `Category` entity here, we still get back `Category` objects. 

Behind the scenes, when we have this `addSelect`, Doctrine basically grabs this `fortuneCookie` data and stores it for later. Then if we ever call `category->getFortuneCookies()`, it realizes that it already has that data. And instead of making a query, it uses the data from the original query. So the really important thing here is that when we do this `addSelect`, it doesn't change what our method returns. It just means that Doctrine has more data in the background to avoid those extra queries. 

All right, so if we actually click back to the homepage where we don't have the search yet, we can see we still have the seven queries here because there we're just using our very simple `findAllOrdered` and we don't have the join. So we should add the join here too, right? Yep, well, yes, probably. Except that I want to show you an alternative solution. See our homepage is kind of unique because we don't really need all the fortune cookie data for each category. The only thing we need is the count. What I mean is in our template, it's not like we're looping over `category.fortuneCookies` and then rendering the actual fortune cookie data. We simply grab this and count them. So if you think about it, having a gigantic query that grabs all of the fortune cookie data just to count them isn't the greatest thing for efficiency. So if you find yourself in this situation, what you can do is actually go into your `Category` entity, find your one-to-many relationship right here, `fortuneCookies`, and on the end of it, we can add `fetch` and then set a string `EXTRA_LAZY`. I'm gonna show you what this does. So when you refresh, watch the query count, it's actually gonna stay at seven. But if we open it up, the queries themselves have changed. The first one's still the same. It's still querying for `category`, but down here, check this out. `SELECT COUNT(*) FROM fortune_cookie`, `SELECT COUNT(*) FROM fortune_cookie`. So still seven queries, but now these are only selecting the count. So when you have `fetch=EXTRA_LAZY` and you're simply counting a collection, Doctrine is now smart enough to select just the count instead of querying for the whole item. Now, if we were to actually loop over this collection and start printing out fortune cookie data, then it would make a full query for the full data. But if all you need to do is count it, then this `fetch=EXTRA_LAZY` can be a really great solution. So choose whichever solution's better for you just based on your situation. All right, I'm gonna click into one of these categories and you can see down here we have two queries. This is sort of a miniature N plus one problem. The first one is selecting the one category. And then the second query is selecting all the fortune cookies for that one category because there's no join. So let's see if we can flex our join skills here to get this down to one query. So in this case, over in our `FortuneController`, we'll work on `showCategory()` action. So what we've done here by typing in `category`, we're actually having Symfony query for this category for us by the ID, which normally is fine. However, in this case, we wanna add a join from category over to fortune cookies. So we need to take control of that query ourselves. So I'm actually going to change this to just have us pass the int ID directly. And then I'm gonna auto wire in `CategoryRepository`, `CategoryRepository`. Then down here, we'll just do the query ourselves by saying `categoryRepository->findWithFortunesJoin($id)`. And before we create that, of course, now we need to add a little `if (!$category)`, then `throw $this->createNotFoundException('Category not found!')`. And you can give that a message if you want to, it doesn't really matter. Perfect. All right, let's hop over to our `CategoryRepository` now. I'm gonna copy that method name and let's create a new public function, `findWithFortunesJoin(int $id): ?Category`. So `Category` if we find one, otherwise it will return null. And then the query is gonna start, you know, much the same way that we're used to. So I could actually steal some from up here, but we're still practicing. So let's do this by hand. Return `this->createQueryBuilder('category')`, use our normal category alias. And then the most important part of this is we're gonna need the `andWhere('category.id = :id')`. And then where we fill in those wildcards with `setParameter()` and whatever we called it like `id`, we'll pass that to `id`. And for some reason I have the word end instead of `id`, that's better. And then `getQuery()`. And then in this case, so far we've been getting an array of results. So if you're returning a collection of results, let's `getResult()`. For us, we want either one, the one that matched the database or null. So we can actually say `getOneOrNullResult()`. And that's it. Now that should get things working. I'm gonna do a little sanity check over here. Oh, it would work if I typed things correctly, but isn't that great? It recognized that it didn't know what that alias was. So it gave us a very clear error that that wasn't defined. And now it works still with our two queries. So let's stick our join in now. Again, we're going from one category to many fortune cookies. So let's say `left join` on `category.the property name`, `fortuneCookies`. And again, order doesn't matter, but I'll put it above `addSelect('fortuneCookie')`. And the part that I forgot is the second argument inside of `join` is the alias for that. So we're gonna alias that join, join entity to `fortuneCookie`. Then we're gonna `select fortuneCookie`. And now what we're looking for down here is this query to go from two to one. Got it. So don't over-optimize that, but if you do have the N plus one problem, that's the solution. Just join and grab all the data at once. 

Alright, so, so far, no matter what we've been doing, either we've been turning a collection of `Category` objects or a single `Category` object. But the point is we've been having Doctrine always give us back objects. What if we just need some data, like a couple of columns or a count or a sum? Let's dig into that next.
