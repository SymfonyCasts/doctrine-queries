# Filters: Automatically Modify Queries

So we now know how we could use our cool new method here to filter out the discontinued fortune cookies. But what if we want to apply some criteria *globally* to all queries for some table? Like automatically telling Doctrine that whenever we query for the fortune cookies, we want to add a `WHERE is_discontinued = false` to that query. This is *totally* possible. To demonstrate, I'll revert our two templates here back to the way they were before. And if I go into "Proverbs"... yep! We can see all three show up again.

The way we do this is by creating something called a "filter". In the `/src` directory, we'll create a new directory called `/Doctrine`. We don't *have* to do this, but it helps with organization. Inside that, create a new class called `DiscontinuedFilter`. This needs to extend `SQLFilter`, and then go to Code Generate (or "command" + "N" on a Mac) and select "Implement Methods". This requires us to have one method: `addFilterConstraint()`.

This is pretty cool. Doctrine is going to automatically call `addFilterConstraint()` when it's building a query, and it will pass us some information about which entity we're querying for. This `ClassMetadata` knows all about our entity - whether it's a fortune cookie or a category - and it's also going to pass us the `$targetTableAlias`, which you'll see us use in a second for the query. You *may* see a deprecation notice, and if you *do*, add a `string` return type to make that happy.

Okay, so we can see what's happening in here, let's do our favorite thing and `dd($targetEntity, $targetTableAlias)`. If you go over and refresh the page... nothing happens. That's because this is *not* called automatically. We need to *activate* it. That's a two-step process.

First, in `/config/packages/doctrine.yaml`, we're going to go tell Doctrine that this exists. You'll need to be anywhere under that ORM key. Here, we can add `filters` and then `fortuneCookie_discontinued`. You'll see where that key is used in a second. You could write anything there. Then, set that to our class: `App\Doctrine\DiscontinuedFilter`. *Easy peasy*.

This is *now* registered with Doctrine, but as you can see over here, it's still not *called*. The last step is to *activate* it, because you might not want this `DiscontinuedFilter` to be used everywhere on your site. So, in our controller... there we go... let's go up here to the homepage and autowire in `EntityManagerInterface $entityManager` and, right on top, we'll say `$entityManager->getFilters()` followed by `->enable()`. Here, we're going to use the same key that we used in `doctrine.yaml` - `fortuneCookie_discontinued`. I'll go grab it, and... *perfect*. Every query we make after this is going to use that filter. If we head over to our homepage and try this again... yes! It hit it! You can see that this `ClassMetadata` is a *big* class that knows all about our entity. And down here, you can see that for whatever query we're making first, the table alias is `c0_`. Now we can get to work!

Once we enable this, it will be called whenever we query for any entity in the system, so the first thing we want to do is say `if ($targetEntity->name !== FortuneCookie::class`. That means we're querying for something else and we'll `return ''`. This method is supposed to return a `string`, and whatever string we return here will basically turn into a `WHERE` clause, so we're just returning empty quotes. At the bottom, `return sprintf('%s.discontinued = false')`, and then we'll pass in the `$targetTableAlias` for that.

Okay, check this out! On the homepage, the "Proverbs" count should go from 3 to 2. It does! And if you check out the query for it, you can see that there's a little `t0.discontinued = false` inside all the queries. That's *awesome*. One *tricky* thing about these filters is that they're not services, so you *can't* have a constructor. It's not allowed. So if we need to pass something into this, we'll have to do it a different way. For example, let's pretend that when we use this filter, sometimes we want to *hide* discontinued and, other times, we only want to *show* discontinued. Essentially, we want to be able to change this value here from `false` to `true` and vice versa.

The way we do that is by changing this to `%s`, and fill that in with `$this->getParameter()`. I'm just going to make up a key here called `discontinued`. You'll see how that's used in a second. i don't *normally* add `%s` inside my queries, because that can allow SQL injection attacks. In this case, it's okay, because we're going to supply this value ourselves.  This value should *never* come from the user. It needs to be something that we always control.

If we head over and try it now... we get a giant error that says:

`Parameter 'discontinued' does not exist.`

I just made up this word - `discontinued`, but as soon as you have a parameter, you need to pass that in when you enable the filter. You can do that with `->setParameter('discontinued')`, and let's say `false`. If we reload now... it's working! And what happens if we change this to `true`? Refresh again and... yep! The number changed again.

So... you're probably thinking: "This is cool, but can I enable a filter *globally*, *automatically*, without needing to put it on my controller like this?" The answer is... *absolutely*. Let's go back and comment this out, and we can see here that our number goes back to 3. To enable it globally, you can actually do this right inside the configuration, but we're going to make this a *little* more complicated. Bump this onto the next line, set that to `class`, set `enabled` to `true`, and just like that, this is going to be enabled *everywhere*. If we tried this, we would get an error because we're missing the parameter, so we also need to say `parameters`, `discontinued: false`. And there you go! Filter is *pretty* sweet.

Next: Let's talk about how to use the handy `IN` operator with a query.
