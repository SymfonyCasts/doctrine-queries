# Raw SQL Queries

Coming soon...

Until then, here is the legacy version: https://symfonycasts.com/screencast/doctrine-queries-legacy/raw-sql-queries

The query builder is fun to use and super powerful, but if you're writing a super complex query, it might be tough to figure out how to work it into the query builder. If you are writing a crazy query, you're probably fetching a few specific columns anyways, so the benefit of using the query builder isn't as strong. So at the end of the day, if you need to, you can always resort to writing raw SQL. So let's see how we can do that in this case. I'm going to comment out our query builder query. And then the first thing we're going to need is a low-level doctrine connection object. We can get that with `$this->getEntityManager()->getConnection()`. And I'm going to dump that. All right, I want to refresh. Awesome. We get this `Doctrine\DBAL\Connection` object. 

So Doctrine is actually two main parts. There's a lower-level part called the DBAL, which stands for a database abstraction library. This is basically a wrapper around PHP's native PDO that adds some features on top of it. So if you want to kind of directly make queries, this lower-level object is going to let you do that. The other part of Doctrine that we've been dealing with so far is the higher-level one called the ORM or object relational mapper. And that's when you get back data, and you put it on to objects. But for this raw SQL query, we're going to deal with this `Connection` object directly. 

Alright, so let's start with a simple query here. So I'll say `$sql = 'SELECT * FROM fortune_cookie';`. So this is now just normal SQL, I'm using MySQL behind the scenes. So now I do need to think about what's my table name. And I happen to know that by default Doctrine underscores my entities to make table names, select star, it's all the normal stuff. Once we have that, we're actually going to create a statement with `$conn->prepare($sql);`. And then we're going to pass that SQL in this is this creates a statement object, it's kind of like when we create the query object with the query builder, it's just an object that is ultimately going to use to execute the query. And then actually execute it, we can say `dd($result->fetchAllAssociative());`.

To actually execute the query, we can say `result = statement->executeQuery()`. And then the last thing, it's a little weird is this kind of you'd think that this might be actually the database results, it's actually not quite that to get the actual data off of the results, you can say `result->fetchAllAssociative()`. So fetch all the rows and give them to us as an associative array. And watching and check this out over here. Perfect. So we get 20 rows. For the 20 fortune cookies in the system, it's just literally the raw data coming from the database. Alright, let's rewrite this query that we have the query builder up here down and raw SQL. I'm actually going to take off this part and I'll paste in the very long query. And I'll go through it, but there's nothing special. So we're selecting some as `fortune printed` the average `category.name` from `fortune_cookie`. And then we do our inner join over to `category`. Now the biggest difference is that when we do a join with the query builder, we can just say `join` across this relationship. And that's all we need to say. Of course, in raw SQL, we need to help it and actually say that we're joining over to `category` and then describe that we're joining on `category.id = fortune_cookie.category_id`. And then the rest is pretty normal `fortune.cookie.category_id = :category`. So even though we're running raw SQL, we're still not going to do something like this. That's a huge no no, that opens you up for SQL injection attacks. So we're still going to use those nice little placeholders `:category`. To fill that in down here, when we execute the query, see this as a `params` argument, we can pass `category`. Again, this time, instead of passing the entire category object like we did before, this is raw SQL. So we're going to pass `category->getId()`. And now see, got it. So a bit more work. But if it's a complex enough query, then that's totally fine. By the way, instead of using `executeQuery()` to pass this `category` thing, another thing you can do, which is a bit more like what you see up here is use that `statement` object and say `bindValue()`. So we can bind value to `category->getId()`. And that's going to give us the same results before. But notice that this returned us an array with like one row in it and array of arrays, we really just want this array right here in this case. So we can do that instead of `fetchAllAssociative()`, you can say `fetchAssociative()`. And now, beautiful, it gives us back just that first row. 

So as you may remember, our method is supposed to return this `CategoryFortuneStats` object that we created last time. But what we have is this associated array, right? And that's really no problem, right? We can just take this `result->fetchAssociative()`. And we say `return new CategoryFortuneStats()`. And then we can just grab the array keys off of `result->fetchAssociative()` to pass them as the correct arguments here, but I'm going to be even lazier than that. So and use the spread operator and named arguments. 

So notice our arguments are called `fortunesPrinted`, `fortunesAverage`, and `categoryName`. Over here, they are `fortunesPrinted`, `fortunesAverage`, and `name` not `categoryName`, but `name`. So first, I'm going to fix that so that it's also called `categoryName`. So let's go down here and I'll add a little `as categoryName`. And then we'll see here. Yep, now it's called `categoryName`. And now we can use named arguments on here. So let me take out the `DD`, we don't need the `return results`. And check this out. I'm gonna say `...$result->fetchAssociative()`. So it's gonna grab that array and then spread it out across those arguments. So we have three named correctly named arguments on there, which is just kind of fun. And now our page works. 

Alright, next, let's talk about organizing our repository. So we can reuse parts of query in multiple methods.
