# Doctrine DQL

Hey there! Welcome to a tutorial that's all about the nerdery around running queries in Doctrine. It sounds simple, but when you start talking about doing joins and groups, and sometimes you want to grab entire objects, sometimes you want to grab just counts or sums, things can get pretty complicated. So in this tutorial, we are going to deep dive into Doctrine queries. We are going to talk about running native SQL queries, the Doctrine query language, filtering collections, fixing the n plus 1 problem, and a ton more. So, let's do it! I highly recommend coding along with me. You can download the course code from this page. After you unzip it, you'll have a start directory with the same code that you see here. There is a nifty `readme.md` file that has all the setup instructions to get your database going. The last step will be to spin over to a terminal, move into the project, and run `symphony serve-d` to start a built-in web server at `127.0.0.1.8000`. I'll cheat, click that, and say hello to our latest innovation, fortune queries. A site that keeps track of all of the fortunes that a fortune cookie company has made, because of course they need to keep track of that, and their categories. It's exactly two pages right now. These are the categories, and you can click into them to see the fortunes behind them and how many we've printed. This is a Symphony 6.2 project, and at this point, it really couldn't be simpler. We have a `Category` entity, a `FortuneCookie` entity, and exactly one controller. There's no fancy queries being done at all. By the way, the project uses MySQL, but pretty much everything we're going to talk about is going to work even if you're using Postgres. Speaking of that one controller, you can see here on the home page, we are auto-wiring the `CategoryRepository`, and we're using the easiest way to query for something in Doctrine. We're calling `findAll()`. Our first trick is going to be super simple, but kind of interesting. I want to reorder these categories by name to make them alphabetical. Now one easy way to do this, honestly, is you could change `findAll()` to `findBy()`. This returns an array that matches a certain criteria, so you could put like `name = foo` here.

A nice trick is you can just leave that empty, and then the second one is an `orderBy`, so you can say something like `name` equals descending like that. We can edit this out. I am turning Copilot off because it's going to do all the coding for me. Copilot, there we go. Any time I do even a remotely custom query, I really like to create custom repository methods so I can centralize all that stuff. We're going to go over here to the repository directory, open up `CategoryRepository`, and inside here we can just add whatever methods we want. Let's create a new one called `public function findAllOrdered()`. This will return an array, and I'm even going to advertise here that it's going to return an array of categories. Before I fill that in, back here we'll call that. We'll say `findAllOrdered()`. Beautiful. Now if you've worked with Doctrine before, you're probably expecting me to use the query builder, and we are going to talk about the query builder in a second, but I'm going to start even simpler here. Doctrine works with a lot of database systems like MySQL, Postgres, MSSQL, and others. Each of these has an SQL language, but they're not all the same. So Doctrine had to invent its own SQL-like language called DQL, or Doctrine Query Language. It's kind of fun. It looks like SQL, except that you refer to classes and properties instead of tables and columns. Check this out. We're going to write a DQL query by hand. So we can say `$dql = 'SELECT category FROM App\Entity\Category as category';`. And over here, this actually means we're selecting everything from category, which means it's actually going to give us back category objects. And that's it. To execute this, we can create what's called a query object. So we can say `$query = $this->getEntityManager()->createQuery($dql);`. And to run that, it's just `$query->getResult();`.
There's also a `query->execute()`. I like using `getResult()`, but it doesn't really matter. So when we go over and try that, nothing changes. It's working though. We just used DQL directly to make that query. So what does it look like to add the `ORDER BY` on there? Well, you can probably guess. It's `ORDER BY`. The interesting thing here is that we don't need to order by `name`. We don't need to think about what's that column in the database. Because our `Category` entity has a `name` property, we don't care what the column is called in the database. It's probably called `name`, but it could be called I like pizza. It doesn't matter because this is a `name` property. Over here, we can say `ORDER BY category.name`. So unlike in SQL, the alias is optional. You can say `ORDER BY name`. In DQL, you're always going to have the alias. So `category.name`. And then we'll say `DESC`. And now, alphabetical. So we write SQL, DQL, and obviously behind the scenes, it's converting that to SQL and then executing that. So it actually looks at see which database layer you're using and translates that into the SQL language for that database system. We can even get the SQL right here. We can say `DD` for dump and die, `getSQL()`. And there it is. That's the actual SQL query being executed. It's got kind of this ugly `C0_` as its alias, but this makes sense. It's grabbing every single column from that table and returning it. Pretty cool. And by the way, you can also see that inside of your profiler. So if we remove that debugging refresh, down here you can see we're making seven queries. We'll talk about why there's seven in a little bit. And if we open that up, boom, there's the first query. And you can see a pretty version of it or even a version that you can run, the runnable version in case you have some variables like where clauses, that will actually fill in the values for you. All right. Next up, we don't usually write DQL by hand. We instead rely on the query builder to give us DQL. So let's check out what that looks like.
