# andWhere() and orWhere()

Our site has this nifty search box up here, which... *doesn't* work. If I hit "enter" to search for "lunch", it *does* add a `?q=lunch` to the end of the URL, but the results haven't changed. We still see all of our categories here. So let's hook this thing up!

Spin over and find our controller, `FortuneController.php`. In order to read that query parameter, we're going to need the `Request` object. It doesn't matter where we do this, so I'll add a new first argument here, typehinted with `Request` (the one from Symfony), hit "tab" to add that `use` statement, and say `$request`. Then we can get the search term down here by saying `$searchTerm = $request->query->get('q')`. We're just using `q` because that's what I chose in my template. You can see that down here in `/templates/base.html.twig`. This is built with a very simple form and `<input type="text" id="search-navbar" name="q" [...]>`. So we're reading the `q` query parameter here and setting the `$searchTerm`.

Below this, `if` we have a `$searchTerm`, I want to set `$categories` to `$categoryRepository->search()` (a method we're about to create) and pass the `$searchTerm`. Then `else`, if we *don't* have a `$searchTerm`, we'll just move the `$categories` logic down here and get that logic the same way we were before. Awesome! Now let's go create that `search()` method.

Over in our repository, I'll say `public funtion search()`. This will take a `string $term` and it's also going to return an `array`. And, like last time, I'm going to add a little bit of PHPDoc here that says this returns an array of `Category[]` objects. I'll also remove this `@param` since it's redundant.

All right, our query is going to start like it did before, except this time, I'm going to add `return` *immediately*. You'll see why in a second. Then we can say `$this->createQueryBuilder()`, and I'll use the same `category` alias. It's good to be consistent with your alias for an entity. And then, for our `WHERE` clause, we're going to use `->andWhere()`. There's also a `where()` method, but I don't recommend using it. We'll play it safe and stick with `andWhere()`. We can use it even if it's our first `WHERE` clause.

The problem with `->where()` is, if you already had some `WHERE` clauses on your QueryBuilder, this would remove those and replace them with whatever you have. So to make sure you're always adding additional `WHERE` clauses, always use `andWhere()`.

Inside this, it's pretty simple. We're going to say `category`, and since we'll search on the `name` property in our entity, we'll say `category.name =`. This next part is *very* important. Never ever *ever* do this. This opens you up for SQL injection attacks. *Instead*, any time you need to put a dynamic part in your query, you're going to put a placeholder. We're going to say `:searchTerm`. This string could be anything. And then we'll fill that in by saying `->setParameter('searchTerm', $term)`. Perfect! And that's all we need for the QueryBuilder.

Now we're going to say `->getQuery()` to turn that into a query object, and then `->getResult()` to actually *execute* that query and return the array of `category` objects. *Sweet*. If we head over and try this... got it! *But* if we take off a couple of letters and search again... we get *nothing*. Ideally, we want the search to be fuzzy, matching any part of the name of a category. And that's an easy fix. We'll just change our `->andWhere()` from `=` to `LIKE`, and down here, for our `searchTerm`, this might look a little weird, but we're going to add percentages right here. This `'%' .$term. '%'` will make it fuzzy on both sides. If we try it now... it works

One other thing you might notice are these little icons right here. Every category has its own little icon. This one has "fa-quote-left" and the one below it has "fa-utensils". This is *also* something that's stored in the database. So... what if I want our site to be able to search by name *or* the icon name? That's simple! We just need to add an `OR` to our query. Down here, you might be tempted to use this nice `->orWhere('category.)` with the name of that property, which, if we look that up in `Category.php` really quick... is `$iconKey`. So `category.iconKey LIKE :searchTerm`. We could do that, right? Not *quite*. I recommend that you avoid using `orWhere`. The problem with `orWhere` is that the logic gets a little weird. For instance, if we have another `->andWhere()` down here, things are going to get confusing. Would that mean that's `andWhere`, then `orWhere` *both* of these things? What exactly would this do? To avoid this weirdness altogether, I always use `andWhere`. And if you need *multiple* things, you can just put an `OR` clause right here, because inside of here, we're just writing DQL. So this would look like `OR category.iconKey LIKE :searchTerm`. In the final SQL, this is basically going to put parentheses around this `WHERE` clause, which helps keep our logic nice and clean.

Okay, spin over and try searching for "utensils". I'll type part of the word and... got it! We're matching on the `iconKey`. And that's it! The last thing we'll do, to make our query similar to the query before, is say `->addOrderBy('category.name', 'DESC')`. If we go to the homepage and just type the letter "p" in the search bar, you can see that it's sorting alphabetically. It can be helpful to check out the query sometimes, and if you check out the formatted query for this, you see it's selecting everything `FROM category c0_`, `WHERE c0_.name LIKE ? OR c0_.icon_key LIKE ?`. That's exactly what we expect. So if you ever have something strange going on with your query, this is a great way to see what it's *actually* doing so you can diagnose the problem.

Next: Let's extend our search so we can search the fortunes *inside* of each category. To do that, we're going to need a `JOIN`.
