# andWhere() and orWhere()

So our site has this nifty search box up here, which absolutely does not work. If I hit empty at launch, it does add a `?q="` to the URL, but as you can see, all of our categories still show up here. So let's hook this thing up. Spin over and find our controller. And in order to read that query parameter, we're going to need the request object. So it doesn't matter where, but I'll add a new first argument, type in it with `Request`, the one from Symfony, so I'll hit tab to add that use statement, `Request`. And then we can get this search term down here by saying `$searchTerm = $request->query->get('q');`. And it's `q` just because that's what I've chosen in my template. I'll show that down here in templates, `fortune`, `homepage.html`, `twig`. Actually `base.html`, `twig`, my bad. You can see here, this is just built with a very simple form with just input name equals q. So we're reading the `q` query parameter here and setting the search term. Now if we have a search term, I want to set categories to a new `CategoryRepository` arrow search method that we're about to create and pass the search term. Else, if we don't have a search term, then we'll just move the categories logic down here and we'll get the category logic the same way as we are already. Awesome. Let's go create that search method. So over in our repository, it'll start the same way. Search, this will take a string term and it's also going to return an array. And like last time, I'm going to add a little bit of phpDoc on that. It says this returns an array of category objects. And I'll remove this param because that's just redundant. All right. So our query is going to start kind of just like the way we did before. I'm actually going to say return immediately. You'll see why in a second. We can say `this->createQueryBuilder('category')`. I'll use the same category alias. It's good to be consistent with your alias for an entity. And then to do a where clause, we're going to use `andWhere`. There is also a `where` method. I recommend not using it. `andWhere` is safe.
We can use it even if it's our first `where` clause. The problem with `where` is that if you already had some `where` clauses on your query builder, this would remove those and replace them with whatever you have. So to make sure that you're always adding additional `where` clauses, always use `andWhere`. And inside of here, it's pretty simple. We're going to say `category`. And we'll search on the `name` property on our entity. So `category.name` equals. And then in here, what we're not going to do is do this. Never ever, ever do that. That opens you up for SQL injection attacks. Instead, any time you need to put a dynamic part in your query, you're going to put a placeholder. So you're going to say `:searchTerm`. This string could be anything. And then you fill that in by saying `setParameter('searchTerm', $term)`. Perfect. And that's all we need for the query builder. So now we're going to say `getQuery()` to turn that into a query object and then `getResult()` to actually execute that query and return the array of category objects. Sweet. Let's try it and got it. But you'll notice if we take off a couple of letters and search again, we get nothing. So ideally we want the search to be fuzzy, matching any part of the name of a category. And this is really not special at all. We just change our `andWhere` from `equals` to `LIKE`. And then down here for our search term, it's a little bit weird, but we're actually going to put the percentages right here. So `%$term%` to make it fuzzy on both sides. And now got it. Now one other thing is you notice these little icons right here. Every category has its own little icon. Like this is quote and the one below it is utensils. That's actually also something that's stored in the database. So what if I want our search to be able to search on the name or the name of the icon? Okay. So we just need an `OR` part of our query. So what you might be tempted to do down here is to use this nice `orWhere()` `category.theNameOfThatProperty`. And actually let me look that up.

If you look at the category, you can see there's an `iconKey` property. So `category.iconKey` like `searchTerm` like that, right? I recommend never doing that. I recommend never using `orWhere`. The problem with `orWhere` is that the logic gets a little fuzzy. Like if we have another `andWhere` down here, what does that mean exactly? Does it mean that's `andWhere` then `orWhere` both of these things or what exactly does this mean? In reality, if we did this, so to be more explicit, I never use `orWhere`. Instead, I always use `andWhere`. And if there are multiple things that you need, you can just put an `OR` clause right in there because inside of here, we're just writing DQL. So `OR category.iconKey LIKE searchTerm`. So you can imagine in the final SQL, this is basically going to put parentheses around this `WHERE` clause so that it helps keep our logic nice and clean. And now let's try utensils. So I'll type the part of that and got it matching on the `iconKey`. And that's it. The last thing to make our query similar to the query before, we'll add an `ORDER BY`. So `addOrderBy('category.name', Criteria::DESC)`. Now if we go to the homepage and let's just type the letter P, you can see it's sorting alphabetically. And once again, sometimes it's nice to check out the query for this. So if you check out the formatted query, you see it's selecting everything from category, where `C.name LIKE` or `C.iconKey LIKE`. Exactly how we'd expect. So if you ever have something kind of weird with your query, this is a great way to go in and see what it's actually doing to see what might be going wrong. All right, next. Let's extend our search to actually search on the fortunes inside of each category. To do that, we're going to need a join.
