# Criteria: Filter Relation Collections

On the category show page, we're looping over all of the fortune cookies in that category. Let's check out that template: `/templates/fortune/showCategory.html.twig`. Okay, we can see that we're looping over `category.fortuneCookies` and rendering some stuff inside of there. So here's the thing: If you look at the `FortuneCookie.php` entity, it has a `bool $discontinued` flag. Occasionally, we stop producing a specific fortune cookie. Right now, on this page, we're looping over *all* of the fortune cookies for a category, which includes cookies we're currently producing *and* those we have discontinued. We're really only interested in seeing the ones we're still making, so we need to find a way to hide our discontinued cookies. How can we do that?

Over in the controller for this page - `FortuneController.php` - we could create a separate query here from the `$fortuneCookieRepository` where we say "where `category` equals this `$category` and `discontinued` equals `false`. But that's kind of lame because it's just so easy to do this inside of our template. So... is there some way to use the `category` object directly to only get the current fortune cookies? The answer is... absolutely! And if we do it correctly, we can do it *really* efficiently.

The first step is optional, but in the controller, I'm going to change `->findWithFortunesJoin()` back to just `->find()`. I'm removing the join we had to make the inner workings of the new feature we're *about* to work on a little more obvious. This doesn't change anything except that our queries go up to three. That's one query for the category, our custom query that we're making, and then one query for all of the fortunes *inside* of this category.

To get this working, we're going to go into our `Category.php` entity and find the `getFortuneCookies()` method. There it is. Right below that, let's create a new method here called `getFortuneCookiesStillInProduction()`. This, like the normal method, is going to return a Doctrine `Collection`. And, just to help it out, copy the `@return` doc above. we'll say that this is a `Collection` that's going to be a `FortuneCookie`, so if we loop over this, our editor is going to know that each item in the `Collection` is a `FortuneCookie` entity.

So... what do we do inside of here? We *could* just loop over `$this->fortuneCookies() as $fortuneCookie` and create an array of new ones that *aren't* discontinued, basically popping this into a new array. The problem with this is, as soon as we call `$this->getFortuneCookies()`, that's going to query for *every* single fortune cookie and then we're going to create a new collection. This new `$inProduction` collection will only contain some of them, though. So we're querying for *all* of them, even though we're only using *some* of them. Pretty wasteful. What we *really* want to do is tell Doctrine to make a fresh query from inside of here to the `FortuneCookieRepository`, where `discontinued` equals `false`.

Normally, we can't make queries from inside of an entity because we need the repository and we don't have access to that. But these relationship properties are an exception to that rule using a really cool system called the *criteria system*. It works like this: We say `$criteria = Criteria::` - the one from Doctrine/Common/Collections - `create()`. This functions a bit like the `QueryBuilder`, but it's not *exactly* the same. We'll say `->andWhere()`, and we can use `Criteria::` again with `expr()->`, and here, we can kind of build our `WHERE` clause. You can see that there's `in`, `contains`, `gt`... but we're going to use `eq()` for "equals". And inside, we'll say `'discontinued', false`. This, on its own, is just creating an object that's describing a `WHERE` clause. Below, we can say `return $this->fortuneCookies->matching($criteria)`. This basically says:

`Take this collection, but only return the ones that match this criteria.`

To actually *use* this method, over in `showCategory.html.twig`, instead of looping over `category.fortuneCookies`, we're going to loop over `category.fortuneCookiesStillInProduction`.

Let's try this! Refresh, and... I don't actually know if any of these are discontinued, but it *did* go from three to two. And the best part? Check out that query! Here's the first one for the category, here's our custom one... but take a look at this last query here. When we ask for the discontinued fortune cookies, it actually queries from `fortune_cookie`, where the `category` is our category and where `t0.discontinued` is false. So it made the most efficient query to just get the fortune cookies that we needed. That's *powerful*.

One weird downside to this right now is that I normally like to keep my query logic inside of my repository. Fortunately, we *can* move it there. Since this is dealing with fortune cookies, I'm going to open `FortuneCookieRepository.php` and, anywhere inside of here, we're going to create a `public static function` called... how about `createFortuneCookiesStillInProductionCriteria()`, and we're going to return a `Criteria` object from here. Then, I'm going to go and grab that `$criteria` statement from our other method... and return that.

Notice that this is a `static` method. There are two reasons for that. These `Criteria` objects aren't actually making queries or anything, so they can be `static`. They can live in a `static` method. But more importantly, we don't have access to our repository object from inside `Category`. So if we're going to call a method on a repository, it has to be `static`.

Now, inside of this, we can say `$criteria =  FortuneCookieRepository::createFortuneCookiesStillInProductionCriteria()`. This has now centralized that logic inside of a repository. You can also reuse these `Criteria` in your queries as well, which is pretty cool. Let's see... I don't have an example at the moment... so if we scroll up a bit... in this method above, let's pretend I'm creating a `QueryBuilder` with `$this->createQueryBuilder('fortune_ cookie')`. And then we can say `->addCriteria(self::createFortuneCookiesStillInProduction)`. So even though the criteria system is a little bit different than our normal QueryBuilder, we can still put them *inside* of QueryBuilders so we can reuse the new method that we just created. And of course, if we head over and refresh... everything *still* works.

Okay, on the homepage, we have a similar problem. This says "Proverbs(3)", and if we click that, there are *two*. This is still showing the count of *all* of the fortune cookies. What's happening here? Over in `homepage.html.twig`... let's see... ah, yes. We're looping over `categories`, and then we're calling `category.fortuneCookies|length` which, as we know, returns *all* of the fortune cookies. Then we're just counting them. Let's change that to `fortuneCookiesStillInProduction`. Back on the homepage, watch this "(3)". It *should* go down to two, and... it *does*. But that's not even the best part. Open up the query for that. Remember, thanks to our fetch `EXTRA_LAZY`, since we're only counting the number of fortune cookies, it knows to make a super fast `COUNT` query for those fortune cookies. But because of the criteria system, it's selecting `COUNT FROM fortune_cookies WHERE` the `category` equals our category and our `discontinued` equals that. So it's still making the most efficient query possible to get this `COUNT`, which is pretty awesome.

Next: We want to hide discontinued fortune cookies from everywhere on our site. Is there a way that we could hook into Doctrine and just add that `WHERE` clause automatically *everywhere*? There *is*. It's called *filters*.

