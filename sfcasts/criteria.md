# Criteria: Filter Relation Collections

Coming soon!

On the category show page, we obviously loop over all the fortune cookies in that category. Let's open up that template. Template's fortune show category.html.twig. Perfect. So we can see we're looping over category.fortuneCookies and then rendering some stuff inside of there. So here's the thing. If you look at the fortune cookie model entity, it has a discontinued Boolean flag. Sometimes we make fortune cookies for a while and then we stop making them. On this page right now, we're looping over all of the fortune cookies for a category, but we really want this to only be the ones we're still making. So we need to somehow hide the ones that are discontinued. How can we do that? Well we could query... I'm resetting that. Well over in the controller for this page, we could actually create a separate query here from the fortune cookie repository where we say where category equals this category and discontinued equals false. That's kind of a bummer because it's just so easy just to do this inside of our template. So is there some way to use the category object directly to just get only the current fortune cookies? The answer is absolutely and if we do it correctly, we can do it really efficiently. To do this, step one, we don't need to do this but on the cat in the controller, I'm going to change find with fortunes join back to just find. So I'm going to remove the join we had. It's just going to make the feature that we're about to show a little more obvious like what's going on behind the scenes. That doesn't change anything except that our queries go up to three. That's one query. If we look at it, that's one query for the category, our custom query that we're making and then one query for all the fortunes inside of this category. Alright to get this working, we're going to go into our category entity and let's find the get fortune cookies method. Perfect. I'll go right below there and we're going to create a new method here called get fortune cookies still in production. And this, like its normal method, is going to return a doctrine collection. And also, like normal, just to help it out, copy the peach we dock above. I'm going to say that this is a collection that's going to be a fortune cookie. So if we loop over this, our editor is going to know that each item in the collection is a fortune cookie entity. Alright, so what do we do inside of here? And we could just like loop over this arrow fortune cookies and create an array and create an array of like new ones that aren't discontinued, like pop this into a new array. The problem with that is that we're going to, doing this, as soon as we call this arrow get fortune cookies, that's going to query for every single fortune cookie and then we're going to create a new collection. This new in production collection is actually going to only contain some of them. So we query for all of them, even though we're only using some of them, which is kind of wasteful. What we really want to do is tell doctrine to make a query from inside of here. A fresh query to the fortune cookie repository where discontinued equals false. Now normally we can't make queries from inside of an entity because we need the repository and we don't have access to that. But these relationship properties are an exception to that using a really cool system called the criteria system. So it works like this. We say criteria equals criteria run from doctrine collections, colon, colon, create. And then this functions a bit like the query builder. It has a lot of similarities, not exactly the same. So we can say and where, and then we can use this criteria again, colon, colon, expression. And then this is a little bit of a weird object, you kind of like build your where clause. So you can see that there's in contains greater than we're going to use EQ for equals. We're going to say discontinued false. So this on its own is just kind of creating an object that's sort of describing a where clause. And then down at the bottom we can say return this arrow fortune cookies, arrow matching. And that takes a criteria object. So it says take this collection but only return the ones that match this criteria. And I'd actually use this method over in our show category instead of looping over category dot fortune cookies, we're going to loop over category dot fortune cookies still in production. All right, let's try this. Refresh. I don't actually know if any of these are discontinued, but yes, it went from three to two. And this is the best part. Check out that query. So here's the number one for the category. Here's our custom one. But check out this last query here. When we ask for the discontinued fortune cookies, it actually queries from fortune cookie where the category is our category and where T dot discontinued is false. So it made it the most efficient query to just get the fortune cookies that we needed. That is powerful. Now one kind of weird downside to this right now is that I normally like to keep my query logic inside of my repository. Unfortunately, we can move it there. Since this is dealing with fortune cookies, I'm going to open fortune cookie repository. And anywhere inside of here, we're going to create a public static method called how about create fortune cookies still in production criteria. And we're going to return a criteria object from here. And then I'm going to go and grab that criteria statement from our other method. And then I'm going to return that. Now notice this is a static method. There's kind of two reasons for that. These criteria objects aren't actually making queries or anything, so they can be static. They can live in a static method. But more importantly, from inside of category, we don't have access to our repository object from inside of here. So if we're going to call a method on a repository, it's going to have to be static. So now inside of here, we can say criteria equals fortune cookie repository colon colon create fortune cookie still in production criteria. And we have now centralized that logic inside of a repository. Another cool thing is that you can actually reuse these criteria inside of your queries as well. Let's see. I don't have an example in here. Let's pretend. Well, let's go up here. Let's pretend in this method above, I'm creating a query builder. And then you can say add criteria, and we can say self colon colon create fortune cookies still in production. So even though the criteria system is a little bit different than our normal query builder, we can still put them inside of query builders so we can reuse that new method that we just created. And of course, we go over here. Everything still works. Now on the homepage, we have kind of a similar problem here. You see it says Proverbs 3, and then we click that there are two. So this is still showing the count of all of the fortune cookies. So let's take a look at what's going on in homepage.html.twig. Let's see. Perfect. Yeah, we're looping over the categories. And then we're calling category.fortunecookies.length. This of course returns all of the fortune cookies, and then we're just counting them. So let's change that to fortune cookies still in production. And now watch this three. Should it go down to two? It does. And you want to know the craziest part? Open up the query for that. Remember, thanks to our fetch extra lazy, because we're only counting the number of item, of fortune cookies, it knows to make a super fast count query for those fortune cookies. But because of the criteria system, check this out, it's selecting count from fortune cookies where the category equals our category and our discontinued equals that. So it's still making the most efficient query possible to get this count, which is pretty awesome. All right, next. So we want to hide discontinued fortune cookies from everywhere on our site. Is the way that we could hook into Doctrine and just add that where clause automatically everywhere? There is. So, filters.

